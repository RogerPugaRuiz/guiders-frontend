# Workflow para deployment de staging
name: Deploy to Staging

on:
  push:
    branches: [develop, staging]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Saltarse tests para deployment r√°pido'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'

jobs:
  # Build y deployment directo
  build-and-deploy:
    name: Build and Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: staging
    
    env:
      STAGING_HOST: '${{ secrets.STAGING_HOST }}'
      STAGING_USER: '${{ secrets.STAGING_USER }}'
      STAGING_DEPLOY_PATH: '/var/www/guiders-frontend-staging'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Install dependencies
        run: |
          npm ci --legacy-peer-deps
          cd guiders-20
          npm ci --legacy-peer-deps

      - name: üß™ Run tests (if not skipped)
        if: ${{ inputs.skip_tests != true }}
        run: |
          echo "üß™ Ejecutando tests r√°pidos..."
          cd guiders-20
          npm run test:jest -- --passWithNoTests --testTimeout=30000 || echo "‚ö†Ô∏è Tests fallaron, continuando deployment"

      - name: üèóÔ∏è Build for staging
        run: |
          echo "üèóÔ∏è Construyendo aplicaci√≥n para staging..."
          cd guiders-20
          npm run build:staging
          
          # Verificar que el build fue exitoso
          if [ ! -f "dist/guiders-20/server/server.mjs" ]; then
            echo "‚ùå Error: server.mjs no fue generado"
            echo "üìÅ Estructura del build:"
            find dist -name "*.mjs" -o -name "server*" | head -10
            exit 1
          fi
          
          echo "‚úÖ Build completado - server.mjs generado correctamente"

      - name: üì¶ Prepare deployment package
        run: |
          echo "üì¶ Preparando paquete de deployment..."
          cd guiders-20
          
          # Crear package.json simplificado para staging
          cat > package-staging.json << 'EOF'
          {
            "name": "guiders-frontend-staging",
            "version": "1.0.0",
            "main": "dist/guiders-20/server/server.mjs",
            "scripts": {
              "start": "node dist/guiders-20/server/server.mjs"
            },
            "dependencies": {
              "@angular/animations": "*",
              "@angular/common": "*",
              "@angular/core": "*",
              "@angular/platform-browser": "*",
              "@angular/platform-server": "*",
              "@angular/router": "*",
              "@angular/ssr": "*",
              "express": "*",
              "rxjs": "*",
              "tslib": "*",
              "zone.js": "*"
            }
          }
          EOF
          
          # Crear tarball
          tar czf ../staging-deploy.tar.gz dist package-staging.json
          
          cd ..
          # Crear script de deployment
          cat > deploy-staging.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail

          echo "üöÄ Iniciando deployment de staging..."

          # Cargar nvm si existe y asegurar Node/pm2 en PATH
          if [ -s "$HOME/.nvm/nvm.sh" ]; then
            . "$HOME/.nvm/nvm.sh"
            nvm use --lts >/dev/null 2>&1 || true
          fi

          if ! command -v pm2 >/dev/null 2>&1; then
            echo "üîß Instalando pm2 global..."
            npm i -g pm2
          fi

          PM2_BIN="$(command -v pm2 || echo pm2)"

          # Asegurar directorio de logs
          sudo mkdir -p /var/log/pm2
          sudo chown -R "$USER":"$USER" /var/log/pm2

          # Detener aplicaci√≥n actual
          echo "üõë Deteniendo aplicaci√≥n actual..."
          "$PM2_BIN" stop guiders-frontend-staging 2>/dev/null || echo "App no estaba corriendo"
          "$PM2_BIN" delete guiders-frontend-staging 2>/dev/null || echo "App no estaba en PM2"

          # Limpiar logs anteriores
          rm -f /var/log/pm2/guiders-frontend-staging*.log || true

          # Descomprimir aplicaci√≥n
          echo "üì¶ Descomprimiendo aplicaci√≥n..."
          tar xzf staging-deploy.tar.gz

          # Usar package.json optimizado
          mv package-staging.json package.json

          # Verificar archivos cr√≠ticos
          if [ ! -f "./dist/guiders-20/server/server.mjs" ]; then
            echo "‚ùå Error: server.mjs no encontrado"
            exit 1
          fi

          echo "‚úÖ Archivos verificados correctamente"

          # Iniciar con PM2
          echo "üöÄ Iniciando aplicaci√≥n..."
          "$PM2_BIN" start ecosystem.staging.config.js --update-env

          # Esperar y verificar
          echo "‚è≥ Esperando inicio de la aplicaci√≥n..."
          sleep 10

          # Verificar estado
          if "$PM2_BIN" list | grep -q "guiders-frontend-staging.*online"; then
            echo "‚úÖ Aplicaci√≥n iniciada correctamente"
            "$PM2_BIN" logs guiders-frontend-staging --lines 10 --nostream
          else
            echo "‚ùå Error al iniciar aplicaci√≥n"
            "$PM2_BIN" logs guiders-frontend-staging --lines 20 --nostream || true
            exit 1
          fi

          echo "‚úÖ Deployment completado!"
          EOF
          
          chmod +x deploy-staging.sh

      - name: ÔøΩÔ∏è Install WireGuard
        run: |
          sudo apt-get update
          sudo apt-get install -y wireguard

      - name: üîê Setup WireGuard private key
        run: |
          if [ -z "${{ secrets.WG_PRIVATE_KEY }}" ] || [ -z "${{ secrets.WG_SERVER_PUBLIC_KEY }}" ] || [ -z "${{ secrets.WG_SERVER_ENDPOINT }}" ]; then
            echo "‚ùå Faltan secrets de WireGuard: WG_PRIVATE_KEY / WG_SERVER_PUBLIC_KEY / WG_SERVER_ENDPOINT"
            exit 1
          fi
          echo "${{ secrets.WG_PRIVATE_KEY }}" | sudo tee /tmp/wg-privatekey >/dev/null
          sudo chmod 600 /tmp/wg-privatekey

      - name: üîß Configure WireGuard interface
        run: |
          set -euo pipefail
          # Variables por defecto (sin depender de secrets opcionales)
          WG_CLIENT_IP="10.0.0.3/24"
          WG_ALLOWED_IPS="10.0.0.0/24"

          # Crear interfaz wg0
          sudo ip link add dev wg0 type wireguard || echo "wg0 ya existe"
          sudo ip address add "$WG_CLIENT_IP" dev wg0 || echo "IP ya asignada"
          sudo wg set wg0 \
            private-key /tmp/wg-privatekey \
            peer "${{ secrets.WG_SERVER_PUBLIC_KEY }}" \
            allowed-ips "$WG_ALLOWED_IPS" \
            endpoint "${{ secrets.WG_SERVER_ENDPOINT }}:51820"
          sudo ip link set up dev wg0
          # Asegurar ruta a la red de la VPN
          sudo ip route add "$WG_ALLOWED_IPS" dev wg0 || true

      - name: üîé Verify VPN connection
        run: |
          set -euo pipefail
          echo "üìã Estado de WireGuard:"
          sudo wg show
          echo ""
          echo "üìã Interfaces WireGuard activas:"
          ip link show type wireguard || true
          echo ""
          echo "üìã Rutas VPN:"
          ip route | grep -E "wg0|10\\.0\\.0\\." || true
          echo ""
          echo "üèì Probando conectividad con el servidor VPN (10.0.0.1)"
          if ping -c 2 -W 3 10.0.0.1 >/dev/null 2>&1; then
            echo "‚úÖ VPN responde"
          else
            echo "‚ùå No hay respuesta del servidor VPN dentro de la red"
            exit 1
          fi
          # Limpiar clave
          sudo rm -f /tmp/wg-privatekey || true

      - name: ÔøΩüì§ Upload files to staging server
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          set -euo pipefail
          echo "üîß Configurando conexi√≥n SSH..."
          sudo apt-get update && sudo apt-get install -y sshpass

          # Validar variables requeridas
          if [ -z "${{ env.STAGING_HOST }}" ] || [ -z "${{ env.STAGING_USER }}" ] || [ -z "${SSH_PASSWORD:-}" ]; then
            echo "‚ùå Faltan variables de entorno/secretos: STAGING_HOST/STAGING_USER/SSH_PASSWORD"
            echo "- STAGING_HOST set: $([ -n "${{ env.STAGING_HOST }}" ] && echo yes || echo no)"
            echo "- STAGING_USER set: $([ -n "${{ env.STAGING_USER }}" ] && echo yes || echo no)"
            echo "- SSH_PASSWORD set: $([ -n "${SSH_PASSWORD:-}" ] && echo yes || echo no)"
            exit 1
          fi

          # Preparar known_hosts (no bloquear si falla)
          mkdir -p ~/.ssh
          ssh-keyscan -H "${{ env.STAGING_HOST }}" >> ~/.ssh/known_hosts || echo "‚ö†Ô∏è ssh-keyscan fall√≥, se continuar√° con UserKnownHostsFile=/dev/null"

          echo "ÔøΩ Probando conexi√≥n SSH..."
          if ! sshpass -p "$SSH_PASSWORD" ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} "echo OK" >/dev/null 2>&1; then
            echo "‚ùå No se pudo establecer conexi√≥n SSH al servidor."
            echo "   Verifica: host/usuario/secreto, Firewall/22, y que PasswordAuthentication est√© habilitado."
            exit 1
          fi

          HOST="${{ env.STAGING_HOST }}"
          echo "üìÅ Creando directorio de staging en $HOST..."
          sshpass -p "$SSH_PASSWORD" ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ${{ env.STAGING_USER }}@"$HOST" \
            "mkdir -p ${{ env.STAGING_DEPLOY_PATH }}"

          echo "üì§ Subiendo archivos..."
          # Subir paquete y script
          sshpass -p "$SSH_PASSWORD" scp -o PreferredAuthentications=password -o PubkeyAuthentication=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            staging-deploy.tar.gz \
            deploy-staging.sh \
            ${{ env.STAGING_USER }}@"$HOST":${{ env.STAGING_DEPLOY_PATH }}/
          # Subir archivo de PM2 desde el repo y renombrarlo en destino
          sshpass -p "$SSH_PASSWORD" scp -o PreferredAuthentications=password -o PubkeyAuthentication=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            .github/ecosystem.staging.config.js \
            ${{ env.STAGING_USER }}@"$HOST":${{ env.STAGING_DEPLOY_PATH }}/ecosystem.staging.config.js

      - name: üöÄ Deploy application
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üöÄ Ejecutando deployment en el servidor..."
          HOST="${{ env.STAGING_HOST }}"
          sshpass -p "$SSH_PASSWORD" ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ${{ env.STAGING_USER }}@"$HOST" \
            "cd ${{ env.STAGING_DEPLOY_PATH }} && chmod +x deploy-staging.sh && ./deploy-staging.sh"

      - name: üîç Verify deployment
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üîç Verificando deployment..."
          HOST="${{ env.STAGING_HOST }}"
          sshpass -p "$SSH_PASSWORD" ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ${{ env.STAGING_USER }}@"$HOST" << 'EOF'
            # Preparar entorno para pm2 (nvm) y utilidades
            if [ -s "$HOME/.nvm/nvm.sh" ]; then
              . "$HOME/.nvm/nvm.sh"
              nvm use --lts >/dev/null 2>&1 || true
            fi
            PM2_BIN="$(command -v pm2 || echo pm2)"
            
            echo "üìä Estado de PM2:"
            "$PM2_BIN" status || echo "‚ö†Ô∏è pm2 no disponible"
            
            echo ""
            echo "üåê Verificando puerto 4001:"
            if command -v ss >/dev/null 2>&1; then
              if ss -lntp | grep -q ':4001'; then
                echo "‚úÖ Puerto 4001 est√° en uso"
              else
                echo "‚ùå Puerto 4001 no est√° en uso"
                echo "Puertos activos (ss):"
                ss -lntp | grep LISTEN || true
              fi
            else
              if netstat -tulpn 2>/dev/null | grep -q :4001; then
                echo "‚úÖ Puerto 4001 est√° en uso"
              else
                echo "‚ùå Puerto 4001 no est√° en uso"
                echo "Puertos activos (netstat):"
                netstat -tulpn 2>/dev/null | grep LISTEN || true
              fi
            fi
            
            echo ""
            echo "üß™ Probando aplicaci√≥n:"
            if curl -f -s --max-time 10 http://localhost:4001 > /dev/null; then
              echo "‚úÖ Aplicaci√≥n responde correctamente"
            else
              echo "‚ùå Aplicaci√≥n no responde"
              echo "üìä Logs recientes:"
              "$PM2_BIN" logs guiders-frontend-staging --lines 10 --nostream || true
            fi
          EOF

      - name: üìã Deployment summary
        if: always()
        run: |
          echo "# üìä Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend API:** http://217.154.105.26/api" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Port:** 4001" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîß Comandos √∫tiles:" >> $GITHUB_STEP_SUMMARY
          echo "```bash" >> $GITHUB_STEP_SUMMARY
          echo "# Ver logs" >> $GITHUB_STEP_SUMMARY
          echo "pm2 logs guiders-frontend-staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Reiniciar" >> $GITHUB_STEP_SUMMARY
          echo "pm2 restart guiders-frontend-staging" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Verificar estado" >> $GITHUB_STEP_SUMMARY
          echo "pm2 status" >> $GITHUB_STEP_SUMMARY
          echo "curl http://localhost:4001" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
