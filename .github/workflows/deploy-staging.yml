# Workflow para deployment de Angular SSR a staging
# .github/workflows/deploy-staging.yml
name: Deploy Angular SSR to Staging

on:
  push:
    branches: [develop, feature/*]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Forzar deployment (skip some checks)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'

jobs:
  # Test b√°sico y build
  test-and-build:
    name: Test and Build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üü¢ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: üì¶ Install root dependencies
        run: npm ci --legacy-peer-deps
      
      - name: üì¶ Install Guiders-20 dependencies
        run: |
          cd guiders-20
          npm ci --legacy-peer-deps
      
      - name: üîç Run lint
        run: |
          cd guiders-20
          npm run lint:guiders-20 || npm run lint || echo "‚ö†Ô∏è Lint no disponible, continuando..."
      
      - name: üèóÔ∏è Build Angular SSR application for staging
        run: |
          cd guiders-20
          npm run build:guiders-20 || npm run build || echo "‚ö†Ô∏è Build command no encontrado"
      
      - name: üß™ Run unit tests
        run: |
          cd guiders-20
          npm run test:jest:guiders-20 || npm run test:unit || echo "‚ö†Ô∏è Tests unitarios no disponibles"

      - name: üìÅ Verify build output
        run: |
          echo "üìÅ Verificando estructura de build..."
          ls -la guiders-20/dist/
          
          # Verificar estructura Angular 20 (siempre tiene el subdirectorio del proyecto)
          if [ -d "guiders-20/dist/guiders-20" ]; then
            echo "‚úÖ Build exitoso - encontrado subdirectorio del proyecto"
            echo "üìÅ Contenido del build principal:"
            ls -la guiders-20/dist/guiders-20/
            
            # Verificar que existen las carpetas browser y server
            if [ -d "guiders-20/dist/guiders-20/browser" ] && [ -d "guiders-20/dist/guiders-20/server" ]; then
              echo "‚úÖ Directorios browser y server encontrados"
              
              # Verificar que server.mjs existe
              if [ -f "guiders-20/dist/guiders-20/server/server.mjs" ]; then
                echo "‚úÖ server.mjs encontrado"
              else
                echo "‚ùå Error: server.mjs no encontrado"
                echo "üìÅ Archivos en server/:"
                ls -la guiders-20/dist/guiders-20/server/
                exit 1
              fi
              
              # Verificar index.html en browser
              if [ -f "guiders-20/dist/guiders-20/browser/index.csr.html" ] || [ -f "guiders-20/dist/guiders-20/browser/index.html" ]; then
                echo "‚úÖ Archivo index HTML encontrado en el cliente"
              else
                echo "‚ùå Error: No se encontr√≥ archivo index HTML en el cliente"
                exit 1
              fi
            else
              echo "‚ùå Error: No se encontraron directorios browser/server"
              exit 1
            fi
          else
            echo "‚ùå Error: No se encontr√≥ el subdirectorio del proyecto en dist/"
            exit 1
          fi

  # Deploy real a staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-and-build]
    if: needs.test-and-build.result == 'success'
    environment: staging
    
    env:
      STAGING_HOST: '${{ secrets.STAGING_HOST }}'
      STAGING_USER: '${{ secrets.STAGING_USER }}'
      STAGING_DEPLOY_PATH: '/var/www/guiders-frontend-staging'
      STAGING_BACKUP_PATH: '/tmp/guiders-frontend-staging-backup'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üü¢ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üîß Install system dependencies
        run: sudo apt-get update && sudo apt-get install -y sshpass wireguard

      - name: üåê Setup WireGuard VPN
        run: |
          echo "üîß Configurando WireGuard VPN..."
          
          # Setup WireGuard private key
          echo "${{ secrets.WG_PRIVATE_KEY }}" > /tmp/privatekey
          sudo chmod 600 /tmp/privatekey

          # Create WireGuard interface
          sudo ip link add dev wg0 type wireguard

          # Configure WireGuard IP
          sudo ip address add dev wg0 10.0.0.3/24 peer 10.0.0.1

          # Configure WireGuard peer
          sudo wg set wg0 \
            listen-port 48123 \
            private-key /tmp/privatekey \
            peer ${{ secrets.WG_SERVER_PUBLIC_KEY }} \
            allowed-ips 10.0.0.0/24 \
            endpoint ${{ secrets.WG_SERVER_ENDPOINT }}:51820

          # Bring up WireGuard interface
          sudo ip link set up dev wg0

          # Cleanup private key
          rm -f /tmp/privatekey

      - name: üîç Verify VPN connection
        run: |
          echo "üîç Verificando conexi√≥n VPN..."
          
          # Mostrar informaci√≥n de la interfaz WireGuard
          echo "üìã Estado de WireGuard:"
          sudo wg show
          
          # Verificar conectividad VPN
          echo ""
          echo "üîç Probando diferentes IPs del servidor VPN..."
          for server_ip in "10.0.0.1" "10.0.0.254"; do
            echo "  Probando $server_ip..."
            if timeout 3 ping -c 1 -W 2 "$server_ip" >/dev/null 2>&1; then
              echo "    ‚úÖ $server_ip responde!"
              VPN_SERVER_IP="$server_ip"
              break
            else
              echo "    ‚ùå $server_ip no responde"
            fi
          done
          
          # Si encontramos un servidor que responde, continuar; si no, fallar
          if [[ -n "${VPN_SERVER_IP:-}" ]]; then
            echo "‚úÖ Conexi√≥n VPN exitosa con servidor $VPN_SERVER_IP!"
          else
            echo "‚ùå No se puede establecer conectividad VPN"
            echo "üö´ DETENIENDO DEPLOYMENT - VPN requerida para acceso seguro"
            exit 1
          fi
          
          # Verificar que podemos alcanzar el servidor de staging a trav√©s de la VPN
          echo ""
          echo "üéØ Probando acceso al servidor de staging:"
          if ping -c 2 -W 5 ${{ env.STAGING_HOST }}; then
            echo "‚úÖ Servidor de staging accesible a trav√©s de VPN!"
          else
            echo "‚ùå No se puede alcanzar el servidor de staging a trav√©s de VPN"
            echo "üö´ DETENIENDO DEPLOYMENT - Servidor de staging no accesible"
            exit 1
          fi

      - name: üîë Add staging server to known_hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ env.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: üèóÔ∏è Build and prepare deployment
        run: |
          echo "üèóÔ∏è Building Angular SSR application for staging..."
          
          # Install dependencies
          npm ci --legacy-peer-deps
          cd guiders-20
          npm ci --legacy-peer-deps
          
          # Build for staging (usar build de desarrollo si no hay espec√≠fico de staging)
          npm run build:guiders-20 || npm run build
          
          # Volver al directorio ra√≠z
          cd ..
          
          # Crear package.json optimizado para staging
          cd guiders-20
          node -e "
            const pkg = JSON.parse(require('fs').readFileSync('package.json'));
            // Optimizar dependencias para staging
            if (pkg.devDependencies) {
              // Mantener solo las dependencias necesarias para SSR
              const productionDeps = {
                '@angular/animations': pkg.dependencies['@angular/animations'],
                '@angular/common': pkg.dependencies['@angular/common'],
                '@angular/compiler': pkg.dependencies['@angular/compiler'],
                '@angular/core': pkg.dependencies['@angular/core'],
                '@angular/forms': pkg.dependencies['@angular/forms'],
                '@angular/platform-browser': pkg.dependencies['@angular/platform-browser'],
                '@angular/platform-browser-dynamic': pkg.dependencies['@angular/platform-browser-dynamic'],
                '@angular/platform-server': pkg.dependencies['@angular/platform-server'],
                '@angular/router': pkg.dependencies['@angular/router'],
                '@angular/ssr': pkg.dependencies['@angular/ssr'],
                'express': pkg.dependencies['express'],
                'rxjs': pkg.dependencies['rxjs'],
                'tslib': pkg.dependencies['tslib'],
                'zone.js': pkg.dependencies['zone.js']
              };
              
              // Filtrar dependencias undefined
              pkg.dependencies = Object.fromEntries(
                Object.entries(productionDeps).filter(([key, value]) => value !== undefined)
              );
              
              delete pkg.devDependencies;
            }
            require('fs').writeFileSync('package-staging.json', JSON.stringify(pkg, null, 2));
          "
          
          # Crear tarball con el build y configuraci√≥n
          tar czf ../deploy-staging.tar.gz dist package-staging.json package-lock.json

      - name: üîß Create staging environment files
        run: |
          echo "üîß Creando archivos de configuraci√≥n para staging..."
          
          # Crear ecosystem.config.js para PM2 staging
          cat > ecosystem.staging.config.js << 'EOF'
          module.exports = {
            apps: [{
              name: 'guiders-frontend-staging',
              script: './dist/guiders-20/server/server.mjs',
              cwd: '/var/www/guiders-frontend-staging',
              instances: 1,
              exec_mode: 'cluster',
              env: {
                NODE_ENV: 'staging',
                PORT: 4001
              },
              error_file: '/var/log/pm2/guiders-frontend-staging-error.log',
              out_file: '/var/log/pm2/guiders-frontend-staging-out.log',
              log_file: '/var/log/pm2/guiders-frontend-staging.log',
              time: true,
              max_memory_restart: '500M',
              node_args: '--max-old-space-size=512'
            }]
          };
          EOF
          
          # Crear script de gesti√≥n segura de PM2 para staging
          cat > pm2-staging-management.sh << 'EOF'
          #!/bin/bash
          
          set -e
          
          APP_NAME="guiders-frontend-staging"
          TIMEOUT=30
          
          echo "üîÑ Gesti√≥n segura de PM2 para $APP_NAME..."
          
          # Funci√≥n para verificar si la app est√° corriendo
          check_app_status() {
            pm2 list | grep -q "$APP_NAME.*online" && return 0 || return 1
          }
          
          # Detener aplicaci√≥n anterior si existe
          if pm2 list | grep -q "$APP_NAME"; then
            echo "üõë Deteniendo aplicaci√≥n anterior..."
            timeout $TIMEOUT pm2 stop "$APP_NAME" || echo "‚ö†Ô∏è Timeout deteniendo aplicaci√≥n"
            timeout $TIMEOUT pm2 delete "$APP_NAME" || echo "‚ö†Ô∏è Timeout eliminando aplicaci√≥n"
          fi
          
          # Iniciar nueva aplicaci√≥n
          echo "üöÄ Iniciando aplicaci√≥n staging..."
          if timeout $TIMEOUT pm2 start ecosystem.staging.config.js; then
            echo "‚úÖ Aplicaci√≥n iniciada con PM2"
            
            # Verificar que est√° corriendo
            sleep 5
            if check_app_status; then
              echo "‚úÖ Aplicaci√≥n est√° corriendo correctamente"
              timeout $TIMEOUT pm2 save || echo "‚ö†Ô∏è No se pudo guardar la configuraci√≥n PM2"
              echo "üìä Estado final:"
              timeout $TIMEOUT pm2 status || echo "‚ö†Ô∏è No se pudo mostrar el estado"
            else
              echo "‚ùå La aplicaci√≥n no est√° corriendo despu√©s del inicio"
              timeout $TIMEOUT pm2 logs "$APP_NAME" --lines 10 --nostream || echo "‚ö†Ô∏è No se pudieron mostrar los logs"
              exit 1
            fi
          else
            echo "‚ùå Error al iniciar la aplicaci√≥n con PM2"
            exit 1
          fi
          EOF
          
          chmod +x pm2-staging-management.sh

      - name: 1Ô∏è‚É£ Prepare deployment info
        run: |
          echo "üöÄ Preparando deployment a staging..."
          echo "üì¶ Archivos listos para deploy:"
          ls -la deploy-staging.tar.gz ecosystem.staging.config.js pm2-staging-management.sh
          
          echo ""
          echo "üìã Informaci√≥n del deploy:"
          echo "- Branch: ${{ github.ref_name }}"
          echo "- Commit: ${{ github.sha }}"
          echo "- Target: ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}"
          echo "- Path: ${{ env.STAGING_DEPLOY_PATH }}"

      - name: 2Ô∏è‚É£ Create staging directory and backup
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üìÅ Creando directorio de staging y backup..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            # Crear backup con timestamp si existe deployment anterior
            if [ -d "${{ env.STAGING_DEPLOY_PATH }}" ]; then
              TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
              BACKUP_DIR="${{ env.STAGING_BACKUP_PATH }}_${TIMESTAMP}"
              
              echo "üì¶ Creando backup en ${BACKUP_DIR}..."
              mkdir -p "${BACKUP_DIR}"
              cp -r ${{ env.STAGING_DEPLOY_PATH }}/* "${BACKUP_DIR}/" || true
              echo "‚úÖ Backup creado exitosamente"
              
              # Mantener solo los √∫ltimos 3 backups para staging
              ls -dt ${{ env.STAGING_BACKUP_PATH }}_* | tail -n +4 | xargs rm -rf || true
            fi
            
            # Crear/recrear directorio de staging
            mkdir -p ${{ env.STAGING_DEPLOY_PATH }}
            mkdir -p ${{ env.STAGING_DEPLOY_PATH }}/logs
            echo "‚úÖ Directorio de staging preparado"
          EOF

      - name: 3Ô∏è‚É£ Upload main files
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì§ Subiendo archivos principales..."
          sshpass -p "$SSH_PASSWORD" scp -o StrictHostKeyChecking=no \
            deploy-staging.tar.gz \
            ecosystem.staging.config.js \
            pm2-staging-management.sh \
            ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }}:${{ env.STAGING_DEPLOY_PATH }}/
          echo "‚úÖ Archivos principales subidos"

      - name: 4Ô∏è‚É£ Extract and prepare application
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì¶ Descomprimiendo aplicaci√≥n..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            cd ${{ env.STAGING_DEPLOY_PATH }}
            
            echo "üì¶ Descomprimiendo aplicaci√≥n Angular SSR..."
            tar xzf deploy-staging.tar.gz
            
            # Usar package.json optimizado si existe
            if [ -f package-staging.json ]; then
              mv package-staging.json package.json
              echo "‚úÖ Usando package.json optimizado para staging"
            fi
            
            # Verificar estructura del deployment
            echo "üìÅ Verificando estructura desplegada:"
            ls -la ./dist/guiders-20/
            
            # Verificar archivos cr√≠ticos
            if [ -f "./dist/guiders-20/server/server.mjs" ]; then
              echo "‚úÖ server.mjs encontrado"
            else
              echo "‚ùå Error: server.mjs no encontrado"
              exit 1
            fi
            
            if [ -d "./dist/guiders-20/browser" ]; then
              echo "‚úÖ Directorio browser encontrado"
            else
              echo "‚ùå Error: Directorio browser no encontrado"
              exit 1
            fi
            
            echo "‚úÖ Aplicaci√≥n descomprimida y verificada exitosamente"
          EOF

      - name: 5Ô∏è‚É£ Prepare server environment
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üõ†Ô∏è Preparando entorno del servidor..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            # Verificar/instalar Node.js si no existe
            if ! command -v node &> /dev/null; then
              echo "üì• Instalando Node.js..."
              curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
              sudo apt-get install -y nodejs
            fi
            
            # Verificar versi√≥n de Node.js
            echo "üü¢ Node.js version: $(node --version)"
            echo "üì¶ NPM version: $(npm --version)"
            
            # Instalar PM2 si no existe
            if ! command -v pm2 &> /dev/null; then
              echo "‚ö° Instalando PM2..."
              npm install -g pm2
            fi
            
            echo "üü¢ PM2 version: $(pm2 --version)"
            
            # Crear directorio de logs de PM2 si no existe
            sudo mkdir -p /var/log/pm2
            sudo chown $USER:$USER /var/log/pm2
            
            echo "‚úÖ Entorno del servidor preparado"
          EOF

      - name: 6Ô∏è‚É£ Install production dependencies
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üì¶ Instalando dependencias de producci√≥n..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            cd ${{ env.STAGING_DEPLOY_PATH }}
            
            # Verificar que package.json existe
            if [ ! -f package.json ]; then
              echo "‚ùå Error: package.json no encontrado"
              exit 1
            fi
            
            echo "üì¶ Instalando dependencias de staging..."
            # Limpiar node_modules anterior
            rm -rf node_modules
            
            # Instalar dependencias
            if [ -f package-lock.json ]; then
              npm ci --omit=dev --legacy-peer-deps
            else
              echo "‚ö†Ô∏è package-lock.json no encontrado, usando npm install"
              npm install --omit=dev --legacy-peer-deps
            fi
            
            echo "‚úÖ Dependencias instaladas exitosamente"
          EOF

      - name: 7Ô∏è‚É£ Start Angular SSR application with PM2
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        timeout-minutes: 10
        run: |
          echo "üöÄ Iniciando aplicaci√≥n Angular SSR de staging..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=10 -o ServerAliveCountMax=3 ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            cd ${{ env.STAGING_DEPLOY_PATH }}
            
            echo "üöÄ Iniciando aplicaci√≥n Angular SSR de staging..."
            
            # Hacer el script ejecutable
            chmod +x pm2-staging-management.sh
            
            # Ejecutar gesti√≥n segura de PM2
            ./pm2-staging-management.sh
            
            echo "‚úÖ Aplicaci√≥n Angular SSR iniciada exitosamente en staging"
          EOF

      - name: 8Ô∏è‚É£ Verify deployment status
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üìä Verificando estado del deployment..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            cd ${{ env.STAGING_DEPLOY_PATH }}
            
            echo "üìä Estado de PM2:"
            pm2 list | grep guiders-frontend-staging || echo "‚ö†Ô∏è Aplicaci√≥n no encontrada en PM2"
            
            echo ""
            echo "üåê Verificando puerto 4001:"
            netstat -tulpn | grep :4001 || echo "‚ö†Ô∏è Puerto 4001 no encontrado en netstat"
            
            echo ""
            echo "üíæ Uso de disco:"
            du -sh ${{ env.STAGING_DEPLOY_PATH }}
            
            echo ""
            echo "üìÅ Estructura final:"
            ls -la ${{ env.STAGING_DEPLOY_PATH }}/dist/guiders-20/
            
            echo "‚úÖ Verificaci√≥n de deployment completada"
          EOF

      - name: 9Ô∏è‚É£ Test application health
        env:
          SSH_PASSWORD: ${{ secrets.STAGING_SSH_PASSWORD }}
        run: |
          echo "üîç Probando salud de la aplicaci√≥n..."
          sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no ${{ env.STAGING_USER }}@${{ env.STAGING_HOST }} << 'EOF'
            # Esperar un momento para que la aplicaci√≥n se inicie completamente
            echo "‚è≥ Esperando que la aplicaci√≥n se inicie completamente..."
            sleep 10
            
            # Probar la aplicaci√≥n localmente
            echo "üîç Probando aplicaci√≥n en localhost:4001..."
            if curl -f -s --max-time 10 http://localhost:4001 > /dev/null; then
              echo "‚úÖ Aplicaci√≥n responde correctamente en puerto 4001"
            else
              echo "‚ùå Aplicaci√≥n no responde en puerto 4001"
              echo "üìä Verificando logs de PM2:"
              pm2 logs guiders-frontend-staging --lines 20 --nostream || echo "‚ö†Ô∏è No se pudieron obtener logs"
              echo ""
              echo "üìä Estado de PM2:"
              pm2 status || echo "‚ö†Ô∏è No se pudo obtener estado de PM2"
              exit 1
            fi
          EOF

  # Resumen final
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [test-and-build, deploy-staging]
    if: always()
    
    steps:
      - name: Show results
        run: |
          echo "# üìä Resumen de Staging Deploy - Frontend Angular SSR" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests & Build:** ${{ needs.test-and-build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy:** ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "## ‚úÖ Deploy Exitoso" >> $GITHUB_STEP_SUMMARY
            echo "Frontend Angular SSR desplegado exitosamente en staging" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üåê URLs de Staging:" >> $GITHUB_STEP_SUMMARY
            echo "- Frontend: http://${{ secrets.STAGING_HOST }}:4001" >> $GITHUB_STEP_SUMMARY
            echo "- Aplicaci√≥n Angular SSR con hexagonal architecture" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üèóÔ∏è Tecnolog√≠as desplegadas:" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Angular 20 con SSR (Server-Side Rendering)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Express.js server (server.mjs)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ PM2 Process Manager (guiders-frontend-staging)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Hexagonal Architecture (Domain + Application + Infrastructure)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîß Gesti√≥n del deployment:" >> $GITHUB_STEP_SUMMARY
            echo "- **PM2 App:** guiders-frontend-staging" >> $GITHUB_STEP_SUMMARY
            echo "- **Puerto:** 4001" >> $GITHUB_STEP_SUMMARY
            echo "- **Logs:** /var/log/pm2/guiders-frontend-staging*.log" >> $GITHUB_STEP_SUMMARY
            echo "- **Path:** /var/www/guiders-frontend-staging" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìä Comandos √∫tiles en el servidor:" >> $GITHUB_STEP_SUMMARY
            echo "```bash" >> $GITHUB_STEP_SUMMARY
            echo "# Ver estado de la aplicaci√≥n" >> $GITHUB_STEP_SUMMARY
            echo "pm2 status guiders-frontend-staging" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Ver logs en tiempo real" >> $GITHUB_STEP_SUMMARY
            echo "pm2 logs guiders-frontend-staging --lines 50" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Reiniciar aplicaci√≥n" >> $GITHUB_STEP_SUMMARY
            echo "pm2 restart guiders-frontend-staging" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Verificar conectividad" >> $GITHUB_STEP_SUMMARY
            echo "curl http://localhost:4001" >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Deploy Fallido" >> $GITHUB_STEP_SUMMARY
            echo "Revisar logs para m√°s detalles" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Pasos para debugging:" >> $GITHUB_STEP_SUMMARY
            echo "1. Verificar logs del workflow en GitHub Actions" >> $GITHUB_STEP_SUMMARY
            echo "2. Verificar conexi√≥n VPN a staging" >> $GITHUB_STEP_SUMMARY
            echo "3. Verificar build de Angular SSR" >> $GITHUB_STEP_SUMMARY
            echo "4. Verificar dependencias de Node.js" >> $GITHUB_STEP_SUMMARY
          fi
